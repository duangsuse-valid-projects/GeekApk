# Lime 的「六个展开」重要思想 🐸

> “三个代表”重要思想是江泽民同志 2000 年 2 月 25 日在广东省考察工作时，从全面总结党的历史经验和如何适应新形势新任务的要求出发，首次对“三个代表”重要思想进行了比较全面的阐述。具体内容为中国共产党始终代表中国先进生产力的发展要求、中国先进文化的前进方向、中国最广大人民的根本利益，是我们党的立党之本、执政之基、力量之源。

3. `((macro sexp) arglist)` 此模式被称为 __『宏求值』__
5. `(macro-value arglist)` 此模式被称为 __『直接施用』__
1. `(symbol arglist)` 此模式被称为 __『解析施用』__
2. `(. handlerid arglist)` 此模式被称为 __『原生调用』__
6. `object` 此模式被称为 __『立即值』__
4. `()` 此模式被称为 __『空链表』__

## 额外展开：

`^#` 定义特殊的宏对象，它接受后面所有 S 表达式，这被称为 __『前置执行宏』__ 或 __『自省宏』__

`(1 args)` 如果对象拥有 `Macro toMacro()` 方法，尝试使用 `toMacro()` 返回的宏
否则，尝试全局的 `(->macro 1)` 返回的宏，如果没有定义直接失败，如果返回的不是宏也失败

所谓「六个展开」可以归纳为三类

## 1. 宏展开

Lime 基于宏和自省功能来实现类似 Scheme 的语法，宏最终被展开为原生调用执行

```scheme
(symbol arglist)
((macro sexp) arglist)
(macro-value arglist)
(object arglist)
```

「宏解析」允许解析「符号」、S 表达式列表、宏对象、可以转换为宏的对象

Apply（施用宏）过程中，S 表达式首项必须是一个能被解析为宏的对象
而其后皆为宏的调用参数。

如果参数长度不对，除非是 `vararg` 宏允许进行填充展开否则抛出 `Arity Mismatch`

## 2. 原生调用

Lime 使用原生调用赋予拥有反射能力的 JVM 方便执行动态操作的能力

```scheme
(. handlerid arglist)
```

> Lime 必须有一个手段把宏变为实际行动（平台上的基本操作），“原生”调用就是 Lime 的实现方法

`handlerid` 其后皆为宏的参数，如果参数长度不对，抛出 `Arity Mismatch`，除非是 `vararg` 接收器

## 3. 无展开

不进行展开，直接返回原对象

```scheme
()
object
```

Lime 不知道该如何展开这些对象，一般它认为这些对象已经被展开，所以直接返回他们

## 传名还是传值？传值还是传引用？

> 局部作用域如何实现？分配在哪里？浅拷贝还是深拷贝？

> 类型检查做不做？动态值类型提升怎么办？

> 模块化可以不可以？支持惰性求值吗？

这些通通不管（其实有些管不了），GeekApk v1 时代的 Lime 是个非常『务实』的解释器，它非常弱智，不喜欢你肯定也不会喷。

